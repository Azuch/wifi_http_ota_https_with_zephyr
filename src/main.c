#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

#include "ca_certificate.h" // Generated by shell script

#include <zephyr/net/net_event.h>
#include <zephyr/net/net_if.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>

#include <zephyr/net/net_ip.h>
#include <zephyr/net/socket.h>
#include <zephyr/net/dns_resolve.h>
#include <zephyr/net/http/client.h>
#include <zephyr/net/tls_credentials.h>

#include <zephyr/net/net_mgmt.h>
#include <zephyr/net/wifi_mgmt.h>

#include <zephyr/storage/flash_map.h>
#include <zephyr/drivers/flash.h>

#include <zephyr/sys/crc.h>
#include <zephyr/sys/reboot.h>

#include <zephyr/dfu/mcuboot.h>

LOG_MODULE_REGISTER(HTTP_WIFI, LOG_LEVEL_INF);

#define SSID "Sehna"
#define PSK "9876543210"
#define TLS_SEC_TAG 42

#define TLS_PEER_HOSTNAME "release-assets.githubusercontent.com"
#define HOSTNAME "192.168.0.189"
#define PORT "443"
#define URL "/firmware.bin"
#define CRC_URL "/firmware.crc"
/* Flash partition - use image-1 for OTA firmware (1.3MB) */
#define DOWNLOAD_PARTITION_ID FIXED_PARTITION_ID(slot1_partition)

static uint8_t write_buffer[8192];
static size_t buffer_offset = 0;
static bool flash_ready = false;
static size_t bytes_written = 0;
static size_t total_expected = 0;

static uint32_t expected_crc = 0;
static uint32_t calc_crc = 0;

static const struct flash_area *storage_area;

static bool wifi_connected = false;
static bool use_flash = false;
static bool upgrade = false;
static bool test_https = true;
static uint8_t buffer[8192];  /* Larger buffer for firmware download */
static int send_req(const char *hostname, const char *port, const char *url, http_response_cb_t callback);

/* Flash write state */
static struct net_mgmt_event_callback wifi_mgmt_cb;

static void wifi_mgmt_handler (struct net_mgmt_event_callback *cb,				uint64_t mgmt_event,
				struct net_if *iface) {
	if (mgmt_event == NET_EVENT_WIFI_CONNECT_RESULT) {
		wifi_connected = true;
	} else {
		wifi_connected = false;
	}
}


static void connect_wifi(void) {
	struct net_if *iface = net_if_get_default();

	struct wifi_connect_req_params params;
	memset(&params, 0, sizeof(params));

	params.ssid = SSID;
	params.psk = PSK;
	params.ssid_length = strlen(SSID);
	params.psk_length = strlen(PSK);
	params.security = WIFI_SECURITY_TYPE_PSK;
	params.channel = WIFI_CHANNEL_ANY;
	params.band = WIFI_FREQ_BAND_2_4_GHZ;

	net_mgmt_init_event_callback(&wifi_mgmt_cb, wifi_mgmt_handler, NET_EVENT_WIFI_CONNECT_RESULT | NET_EVENT_WIFI_DISCONNECT_RESULT);
	net_mgmt_add_event_callback(&wifi_mgmt_cb);
	net_mgmt(NET_REQUEST_WIFI_CONNECT, iface, &params, sizeof(params));
}

static int create_and_connect_socket(const struct addrinfo *addr_info) {
	int sock;
	int ret;

	sock = socket(addr_info->ai_family, addr_info->ai_socktype, addr_info->ai_protocol);

	if (sock < 0) {
		LOG_ERR("Failed to create socket");
		return -errno;
	}

	LOG_INF("Connecting to server...");

	ret = connect(sock, addr_info->ai_addr, addr_info->ai_addrlen);
	
	if (ret < 0) {
		LOG_ERR("Connect failed");
		close(sock);
		return -errno;
	}

	LOG_INF("Connected");
	return sock;
}

static void reset_buffer(void) {
                total_expected = 0;
                bytes_written = 0;
                memset(write_buffer, 0, sizeof(write_buffer));
                buffer_offset = 0;
}

static int http_response_flash_cb(struct http_response *rsp,
				enum http_final_call final_call,
				void *user_data) {
	int ret;

	if (total_expected == 0) {
		total_expected = rsp->content_length;
	}

	/* Process body fragment */
	if (rsp->body_frag_len > 0 && flash_ready) {
		calc_crc = crc32_ieee_update(calc_crc,
                             (const uint8_t *)rsp->body_frag_start,
                             rsp->body_frag_len);
		/* Flush if fragment won't fit */
		if (buffer_offset + rsp->body_frag_len > sizeof(write_buffer)) {
			ret = flash_area_write(storage_area, bytes_written,
						write_buffer, buffer_offset);
			if (ret < 0) {
				LOG_ERR("Flash write failed");
				return ret;
			}

			bytes_written += buffer_offset;
			buffer_offset = 0;
		}

		/* Copy fragment to buffer */
		memcpy(write_buffer + buffer_offset, rsp->body_frag_start, rsp->body_frag_len);
		buffer_offset += rsp->body_frag_len;

		/* Write if buffer is full */
		if (buffer_offset >= sizeof(write_buffer)) {
			ret = flash_area_write(storage_area, bytes_written,
						write_buffer, sizeof(write_buffer));
			if (ret < 0) {
				LOG_ERR("Flash write failed");
				return ret;
			}
			bytes_written += sizeof(write_buffer);
			buffer_offset = 0;
		}
	}

	/* Final flush */
	if (final_call == HTTP_DATA_FINAL) {
		if (buffer_offset > 0 && flash_ready) {
			ret = flash_area_write(storage_area, bytes_written,
						write_buffer, buffer_offset);
			if (ret < 0) {
				LOG_ERR("Flash write failed");
				return ret;
			}

			bytes_written += buffer_offset;
			buffer_offset = 0;
		}

		LOG_INF("Download completed. Verifying...");

		if (bytes_written != total_expected) {
			LOG_WRN("Size mismatching, expected: %zu; get: %zu", total_expected, bytes_written);
			return -EIO;
		}

		LOG_INF("Verified!");
		reset_buffer();
	}

	return 0;
}


static int load_tls_credentials(void) {
	int ret;

	ret = tls_credential_add(TLS_SEC_TAG, TLS_CREDENTIAL_CA_CERTIFICATE,
				 ca_certificate, sizeof(ca_certificate));
	if (ret < 0) {
		LOG_ERR("Failed to register CA certificate: %d", ret);
		return ret;
	}

	LOG_INF("TLS credentials loaded (%zu bytes)", sizeof(ca_certificate));
	return 0;
}

static int http_response_ram_cb (struct http_response *rsp,
                                enum http_final_call final_call,
 				void *user_data) {
	if (total_expected == 0) {
		total_expected = rsp->content_length;
	}
	if (rsp->body_frag_len > 0) {
		memcpy(write_buffer+buffer_offset, rsp->body_frag_start, rsp->body_frag_len);
		buffer_offset += rsp->body_frag_len;
	}

	if (final_call == HTTP_DATA_FINAL) {
		LOG_INF("Download completed. Verifying...");
		if (buffer_offset != total_expected) {
                        LOG_WRN("Size mismatching, expected: %zu; get: %zu", total_expected, buffer_offset);
                        return -EIO;
                }
		expected_crc = strtoul((char *)write_buffer, NULL, 16);
                LOG_INF("Verified! The content is 0x%08x", expected_crc);
                reset_buffer();
	}

	return 0;
}

static void prepare_flash(void) {
	int ret;
        /* Open download partition */
        ret = flash_area_open(DOWNLOAD_PARTITION_ID, &storage_area);
        if (ret < 0) {
                LOG_ERR("Failed to open download partition: %d", ret);
        }
        LOG_INF("Download partition opened, size: %zu bytes", storage_area->fa_size);

        /* Erase partition before writing */
        LOG_INF("Erasing storage partition...");
        ret = flash_area_erase(storage_area, 0, storage_area->fa_size);
        if (ret < 0) {
                LOG_ERR("Failed to erase partition: %d", ret);
                flash_area_close(storage_area);
        }
        LOG_INF("Partition erased");
	flash_ready = true;
}

static void request_boot_upgrade(void) {
	k_sleep(K_MSEC(1000));

	LOG_INF("The system now is pending to upgrade...");

	boot_request_upgrade(BOOT_UPGRADE_TEST);

	LOG_INF("Pending accepted, rebooting...");

	k_sleep(K_SECONDS(1));

	sys_reboot(SYS_REBOOT_COLD);

	return;
}


static int https_cb(struct http_response *rsp,
                    enum http_final_call final_call,
                    void *user_data)
{
    if (rsp->body_frag_len > 0) {
        LOG_INF("Fragment received: %d bytes",
                rsp->body_frag_len);
    }

    if (final_call == HTTP_DATA_FINAL) {
        LOG_INF("Download complete");
    }

    return 0;
}
static int send_https_req(void) {
	int ret;
	int sock = -1;

	struct addrinfo *res;
	struct addrinfo hints = {0};

	k_sleep(K_SECONDS(1));

	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	
	LOG_INF("Step 1: resolving DNS: %s:%s", TLS_PEER_HOSTNAME, PORT);
	ret = getaddrinfo(TLS_PEER_HOSTNAME, PORT, &hints, &res);

	if (ret != 0) {
		LOG_ERR("Error in getaddrinfo for https");
		return -EIO;
	}

	if (res == NULL) {
		LOG_ERR("Could not resolve %s:%s", TLS_PEER_HOSTNAME, PORT);
		return -ENOENT;
	}

	const sec_tag_t sec_tag_list[] = {
		TLS_SEC_TAG
	};

	LOG_INF("Step 2: creating socket");
	sock = socket(res->ai_family, res->ai_socktype, IPPROTO_TLS_1_2);
	if (sock < 0) {
		LOG_ERR("Could not create socket for https");
		return -errno;
	} else {
		LOG_INF("Step 3: setting TLS options");
		ret = setsockopt(sock, SOL_TLS, TLS_SEC_TAG_LIST,
				sec_tag_list, sizeof(sec_tag_list));
		if (ret < 0) {
			LOG_ERR("Failed to set sockopt: %d", -errno);
			return -errno;
		}

		ret = setsockopt(sock, SOL_TLS, TLS_HOSTNAME,
				TLS_PEER_HOSTNAME, strlen(TLS_PEER_HOSTNAME));
		if (ret < 0) {
			LOG_ERR("Could not set TLS_HOSTNAME: %d", -errno);
			return -errno;
		}
	}

	LOG_INF("Connecting to server...");

	ret = connect(sock, res->ai_addr, res->ai_addrlen);

	if (ret < 0) {
		LOG_ERR("Connect failed");
		close(sock);
		return -errno;
	}

	LOG_INF("Connected");
	
	if (sock < 0) {
		freeaddrinfo(res);
		return sock;
	}

	char host_with_port[256];
	snprintf(host_with_port, sizeof(host_with_port), "%s:%s", TLS_PEER_HOSTNAME, PORT);

	LOG_INF("Sending HTTPS request...");
	
        struct http_request req;

        memset(&req, 0, sizeof(req));

        req.method = HTTP_GET;
        req.host = host_with_port;
        req.protocol = "HTTP/1.1";
        req.url = "/github-production-release-asset/1163825255/9589cb09-ec22-4aee-9631-e8f271a303dd?sp=r&sv=2018-11-09&sr=b&spr=https&se=2026-02-23T13%3A49%3A05Z&rscd=attachment%3B+filename%3Dfirmware.bin&rsct=application%2Foctet-stream&skoid=96c2d410-5711-43a1-aedd-ab1947aa7ab0&sktid=398a6654-997b-47e9-b12b-9515b896b4de&skt=2026-02-23T12%3A48%3A48Z&ske=2026-02-23T13%3A49%3A05Z&sks=b&skv=2018-11-09&sig=xcEXkNSS8SZ3JoMlJl2QVRkNT68eTIDeA5gTGzt5XEc%3D&jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmVsZWFzZS1hc3NldHMuZ2l0aHVidXNlcmNvbnRlbnQuY29tIiwia2V5Ijoia2V5MSIsImV4cCI6MTc3MTg1MTQzNSwibmJmIjoxNzcxODUxMTM1LCJwYXRoIjoicmVsZWFzZWFzc2V0cHJvZHVjdGlvbi5ibG9iLmNvcmUud2luZG93cy5uZXQifQ.hiMlWu5peYQeHfjJnlnquvSHIW3MA_c6nBBKUcpFeZ4&response-content-disposition=attachment%3B%20filename%3Dfirmware.bin&response-content-type=application%2Foctet-stream";
        req.response = https_cb;
        req.recv_buf = buffer;
        req.recv_buf_len = sizeof(buffer);

        ret = http_client_req(sock, &req, 60000, NULL);  /* Increased timeout for large files */

        if (ret < 0) {
                LOG_WRN("Client get failed");
        }

        close(sock);
        freeaddrinfo(res);

        LOG_INF("What the hell! For real? I went to this step? Holly shiiiit.");

        return 0;
}

int main(void) {
	connect_wifi();
	while (!wifi_connected) {
		k_sleep(K_MSEC(100));
	}

	// Wait a bit for network to be fully ready
	k_sleep(K_SECONDS(3));

	load_tls_credentials();

	// Load TLS credentials before any HTTPS
	if (upgrade) {
		LOG_INF("Hi, this is version 1 and i want upgrade");
		prepare_flash();
		send_req(HOSTNAME, PORT, URL, http_response_flash_cb);
		send_req(HOSTNAME, PORT, CRC_URL, http_response_ram_cb);
		if (calc_crc == expected_crc) {
			request_boot_upgrade();
		} else {
			LOG_ERR("Mismatching calc_crc vs expected_crc: 0x%08x vs 0x%08x", calc_crc, expected_crc);
		}
		return 0;
	} else {
		LOG_INF("HI, this is version 2 and i dont want upgrade");
		send_https_req();
	}
}

static int send_req(const char *hostname, const char *port, const char *url, http_response_cb_t callback) {

	int ret;
	int sock = -1;
	struct addrinfo *res;
	struct addrinfo hints = {0};

	// Small delay to ensure network is fully ready for DNS resolution
	k_sleep(K_SECONDS(1));

	/* Reset write state */
	bytes_written = 0;
	buffer_offset = 0;

	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;

	ret = getaddrinfo(hostname, port, &hints, &res);

	if (ret != 0) {
		LOG_ERR("ERR inside getaddrinfo: %d", ret);
		return -EIO;
	}

	if (res == NULL) {
		LOG_ERR("Could not resolve hostname");
		return -ENOENT;
	}

	sock = create_and_connect_socket(res);

	if (sock < 0) {
		freeaddrinfo(res);
		return sock;
	}

	LOG_INF("Sending HTTP request...");

	struct http_request req;

	memset(&req, 0, sizeof(req));

	req.method = HTTP_GET;
	req.host = hostname;
	req.port = port;
	req.protocol = "HTTP/1.1";
	req.url = url;
	req.response = callback;
	req.recv_buf = buffer;
	req.recv_buf_len = sizeof(buffer);

	ret = http_client_req(sock, &req, 60000, NULL);  /* Increased timeout for large files */

	if (ret < 0) {
		LOG_WRN("Client get failed");
	}

	flash_ready = false;
	close(sock);
	freeaddrinfo(res);

	LOG_INF("What the hell! For real? I went to this step? Holly shiiiit.\nUhm, i mean Firmware ready for update");

	return 0;
}
